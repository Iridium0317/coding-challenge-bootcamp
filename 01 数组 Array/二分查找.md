二分查找

# 704. Binary Search
[LeetCode Link](https://leetcode.cn/problems/binary-search/)

**Problem**  
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

**Example**

```text
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Constraints:
1 <= nums.length <= 104
-104 < nums[i], target < 104
All the integers in nums are unique.
nums is sorted in ascending order.

```

## My Understanding

### Solution
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        lo, hi = 0, len(nums)-1
        while lo <= hi:
            mid = (lo+hi)//2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                lo = mid+1
            else:
                hi = mid-1
        return -1
```
**Note**

*   Time Complexity: $O(N log N)$
*   Space Complexity: $O(N)$
---

# 35. Search Insert Position
[LeetCode Link](https://leetcode.cn/problems/search-insert-position/)


**Problem**  
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

**Example**

```text
Input: nums = [1,3,5,6], target = 5
Output: 2

Input: nums = [1,3,5,6], target = 2
Output: 1

Input: nums = [1,3,5,6], target = 7
Output: 4
```

**My Understanding**

```text

```

**Solution**

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right :
            mid = (left+right)//2
            if target == nums[mid]:
                return mid
            elif target < nums[mid]:
                right = mid -1
            else:
                left = mid +1
        return right + 1 
```
**Note**

*   Time Complexity: $O(\log N)$
*   Space Complexity: $O(1)$

---
# 34. Find First and Last Position of Element in Sorted Array
[LeetCode Link](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

**Problem**  
Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.

If `target` is not found in the array, return `[-1, -1]`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example**

```text
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

Input: nums = [], target = 0
Output: [-1,-1]
```

**Constraints:**
*   0 <= nums.length <= 10$^{5}$
*   -10$^{9}$ <= nums[i] <= 10$^{9}$
*   `nums` is a non-decreasing array.
*   -10$^{9}$ <= target <= 10$^{9}$

## My Understanding

### Note
```text
1. 看到 Sorted Array有序数组 + Find 查找/搜索 立刻想到 Binary Search 二分查找
2. 题目要求`O(log n)` runtime complexity -> 二分查找，不能用快慢指针遍历
```

### Solution
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        
        def findLeft(nums, target):
            left, right = 0, len(nums) - 1
            idx = -1
            while left <= right:
                mid = left + (right - left) // 2
                
                if nums[mid] > target:
                    right = mid - 1
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    idx = mid          
                    right = mid - 1   
            return idx

   
        def findRight(nums, target):
            left, right = 0, len(nums) - 1
            idx = -1
            while left <= right:
                # 防溢出写法
                mid = left + (right - left) // 2
                
                if nums[mid] > target:
                    right = mid - 1
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    idx = mid          
                    left = mid + 1     
            return idx


        left_bound = findLeft(nums, target)
        right_bound = findRight(nums, target)
        
        return [left_bound, right_bound]
```
**Complexity**

*   Time Complexity: $O(log N)$
*   Space Complexity: $O(1)$

---
# 69. Sqrt(x)
[LeetCode Link](https://leetcode.cn/problems/sqrtx/)

**Problem**  
Given a non-negative integer `x`, return *the square root of `x` rounded down to the nearest integer*. The returned integer should be **non-negative** as well.

You **must not use** any built-in exponent function or operator.
*   For example, do not use `pow(x, 0.5)` or `x ** 0.5`.

**Example**

```text
Input: x = 4
Output: 2
Explanation: The square root of 4 is 2, so we return 2.

Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.
```

**Constraints:**
*   $0 \le x \le 2^{31} - 1$

## My Understanding

### Note
```text

```

### Solution
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x ==0:
            return 0
        if x == 1:
            return 1

        left = 0
        right = x
        while left <=right:
            mid = left + (right - left) // 2
            if mid*mid == x:
                return mid 
            elif mid*mid<x:
                left = mid + 1
            else:
                right = mid -1

        return right         
```
**Complexity**

*   Time Complexity:
*   Space Complexity:

---
# 367. Valid Perfect Square
[LeetCode Link](https://leetcode.cn/problems/valid-perfect-square/)

**Problem**  
Given a positive integer `num`, return `true` *if* `num` *is a perfect square or* `false` *otherwise*.

A **perfect square** is an integer that is the square of an integer. In other words, it is the product of some integer with itself.

You must not use any built-in library function, such as `sqrt`.

**Example**

```text
Input: num = 16
Output: true

Input: num = 14
Output: false
```

**Constraints:**
*   1 <= num <= 2^31 - 1

## My Understanding

### Note
```text

```

### Solution
```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1: return True
        left, right = 0, num // 2
        while left<=right :
            mid = left + (right - left) // 2
            if mid*mid == num:
                return True
            elif mid*mid < num:
                left = mid+1
            else:
                right = mid-1
            
        return False
```
**Complexity**

*   Time Complexity: 
*   Space Complexity: 

---
