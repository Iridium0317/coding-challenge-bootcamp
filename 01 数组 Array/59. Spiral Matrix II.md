# 59. Spiral Matrix II
[LeetCode Link](https://leetcode.cn/problems/spiral-matrix-ii/description/)

**Problem**  
Given a positive integer `n`, generate an `n × n` matrix filled with numbers from `1` to `n²` in spiral order (clockwise, from outer layer to inner layer).

**Example**  
<img width="339" alt="image" src="https://github.com/user-attachments/assets/35368963-9d7b-4d59-b107-12d87812b171" />

## My Understanding

### Note

```text
matrix = [[0]*n for _ in range(n)]  # 初始化 n x n 矩阵
```

### Solution

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix = [[0]*n for _ in range(n)]  # 初始化 n x n 矩阵
        l, r = 0, n - 1
        t, b = 0, n - 1
        num = 1
        target = n * n
        
        while num <= target:
            for i in range(l, r + 1):
                matrix[t][i] = num
                num += 1
            t += 1
            
            for i in range(t, b + 1):
                matrix[i][r] = num
                num += 1
            r -= 1
            
            for i in range(r, l - 1, -1): 
                matrix[b][i] = num
                num += 1
            b -= 1
            
            for i in range(b, t - 1, -1):
                matrix[i][l] = num
                num += 1
            l += 1
            
        return matrix
```
**Complexity**

*   Time Complexity: $O(n^2)$ 必须把 $n^2$ 个空填满。
*   Space Complexity: $O(1)$
---

# 54. Spiral Matrix II
[LeetCode Link](https://leetcode.cn/problems/spiral-matrix/description/)

**Problem**  
Given an `m x n` matrix, return all elements of the matrix in spiral order (clockwise, from outer layer to inner layer).

**Example**  
<img width="383" alt="image" src="https://github.com/user-attachments/assets/a7b49244-c5a9-4ac4-833d-7c5726a9274a" />

## My Understanding

### Note

```text
和上一题类似
```

### Solution

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        # 边界情况：空矩阵
        if not matrix or not matrix[0]:
            return []
            
        m, n = len(matrix), len(matrix[0])
        res = []
        
        up, down = 0, m - 1
        left, right = 0, n - 1
        
        while True:
            # 1. Left -> Right
            for i in range(left, right + 1):
                res.append(matrix[up][i])
            up += 1
            if up > down: break
            
            # 2. Up -> Down
            for i in range(up, down + 1):
                res.append(matrix[i][right])
            right -= 1
            if left > right: break
            
            # 3. Right -> Left
            for i in range(right, left - 1, -1):
                res.append(matrix[down][i])
            down -= 1
            if up > down: break
            
            # 4. Down -> Up
            for i in range(down, up - 1, -1):
                res.append(matrix[i][left])
            left += 1
            if left > right: break
            
        return res
```
**Complexity**

*   Time Complexity:  $O(M \times N)$
*   Space Complexity: $O(1)$
---

